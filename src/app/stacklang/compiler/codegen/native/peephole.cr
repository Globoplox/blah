class Stacklang::Native::Generator

  # Run a set of optimization on assembled instructions
  # by checking for patterns that can be replaced with smaller footprint
  # without altering meaning.
  #
  # Particluarly it seeks to optimize the native code generated by
  # `ThreeAddressCode::JumpEq`.
  # It systematically produce the worst scenario native code as it cannot yet ensure that the relative symbol
  # will fit in a beq immediate:
  # For inconditonnal jump:
  # lui  |  addi  |   jalr -> ...
  # For conditonnal jump:
  #                                     +------------------------------------+
  #                                     |                                    |
  # lui  |  addi  |  beq(condition)  |  beq(inconditionnal)  |  jalr -> ...  |  next instructions
  #                           |                                  |
  #                           +----------------------------------+
  #
  # Once the full function is assembled, it is possible to compute the relative distance between jump targets and the jump instruction
  # (for local symbols but they are the only symbols used with JumpEq).
  # Since beq target are relatives and can be provided within the beq instruction as long as they fit a 7 bit signed int,
  # we can then replace a variety of patterns with a single beq.
  # Since we will only shring the code, every time we optimize a pattern, we might unlock
  # more places where target and jump are near enough, ect, ect. 
  # 
  # The patterns will be seeked by scanning from start to end then applying all detected changes.
  #
  def peephole_optimize

    # An array that contain 1 for each instruction, each instruction
    # removed is replaced by 0.
    # Used to track real new offset values for definitions and references. 
    sum_text = Array(UInt8).new @text.size, 1u8
    text = @text.clone

    # All defined local symbol, sorted by address.
    # Note that since address are relative to text start,
    # they can also be used as offset in the `sum_array`
    definitions = @section.definitions.compact_map do |name, symbol|
      next if symbol.exported
      {name: name, symbol: symbol, new_address: symbol.address}
    end.sort_by &.[:symbol].address


    # For all instruction, if there is a reference to a local symbol, set to the offset in `definitions`
    references = Array({name: String, ref: RiSC16::Object::Section::Reference, definition_offset: Int32?, new_address: Int32}?).new @text.size, nil
    references_swap = Array({name: String, ref: RiSC16::Object::Section::Reference, definition_offset: Int32?, new_address: Int32}?).new @text.size, nil
    @section.references.each do |name, refs|
      definition_offset = definitions.index(&.[:name].== name)
      refs.each do |ref|
        references[ref.address] = {name: name, ref: ref, definition_offset: definition_offset, new_address: ref.address.to_i}
      end
    end

    optimization_happened = true
    # Scan code for patterns. 
    # If one is found, process it, then restart sacnning from start.
    # Stop once we hade one full scan withotu any optimizable pattern found. 
    while optimization_happened
      optimization_happened = false

      # Biggest pattern in 5 isntruction
      t0 = text[0]?.try { |inst| RiSC16::Instruction.decode inst }
      t1 = text[1]?.try { |inst| RiSC16::Instruction.decode inst }
      t2 = text[2]?.try { |inst| RiSC16::Instruction.decode inst }
      t3= text[3]?.try { |inst| RiSC16::Instruction.decode inst }
      t4 = text[4]?.try { |inst| RiSC16::Instruction.decode inst }

      text.each_index do |i|
        if detect_beq_noop(i, t0, references, sum_text) ||
          detect_local_near_jumpeq(i, t0, t1, t2, t3, t4, references, definitions, sum_text, text) ||
          detect_local_near_move_jalr(i, t0, t1, t2, references, definitions, sum_text, text)
          optimization_happened = true
          break
        end

        # Swap roll
        t0 = t1
        t1 = t2
        t2 = t3
        t3 = t4
        t4 = text[i + 5]?.try { |inst| RiSC16::Instruction.decode inst }
      end

      if optimization_happened

        # If an optimization happened, instruction have been removed, which mean
        # all symbols definition value and references address change.
        # We compute their new location in [:new_address]
        sum = 0
        definition_cursor = 0
        # For old text addresses
        sum_text.each_index do |i|

          references[i]?.try do |entry|
            references[i] = {
              name: entry[:name],
              ref: entry[:ref],
              definition_offset: entry[:definition_offset],
              new_address: sum
            }
          end

          if definition_cursor < definitions.size
            while definition_cursor < definitions.size && definitions[definition_cursor][:symbol].address == i
              definitions[definition_cursor] = {
                name: definitions[definition_cursor][:name],
                symbol: definitions[definition_cursor][:symbol],
                new_address: sum # location in new text
              }
              definition_cursor += 1
            end
          end

          # Sum of actual instruction in new text
          sum += sum_text[i]
        end

      end
    end

    # We have found al optimization we could.

    # Apply new text
    @text = text.map_with_index do |instruction, i|
      if sum_text[i] == 1
        instruction
      else
        nil
      end
    end.compact

    # Apply new references address
    @section.references = references.compact.group_by(&.[:name]).map do |name, entries|
      entries.each_with_index do |entry|

        entry[:ref].address = entry[:new_address].to_u16
      end
      {name, entries.map(&.[:ref])}
    end.to_h

    # Apply new definitions address
    definitions.each do |entry|
      entry[:symbol].address = entry[:new_address]
    end

  end

  def detect_beq_noop(i, t0, references, sum_text)
    return false unless t0 && t0.opcode.beq? && t0.reg_a == 0 && t0.reg_b == 0 && t0.immediate == 0 && references[i]?.nil?
    return false unless sum_text[i] == 1
    sum_text[i] = 0
    return true
  end

  def detect_local_near_jumpeq(i, t0, t1, t2, t3, t4, references, definitions, sum_text, text)
    return false unless t0 && t1 && t2 && t3 && t4
    return false unless sum_text[i] == 1 && sum_text[i + 1] == 1 && sum_text[i + 2] == 1 && sum_text[i + 3] == 1 && sum_text[i + 4] == 1
    return false unless t0.opcode.lui? && t1.opcode.addi? && t2.opcode.beq? && t3.opcode.beq? && t4.opcode.jalr?
    address_reg = t0.reg_a
    return false unless t1.reg_a == address_reg && t1.reg_b == address_reg && t4.reg_b == address_reg
    return false unless t4.reg_a == 0
    return false unless t4.immediate == 0
    comp_reg_a = t2.reg_a
    comp_reg_b = t2.reg_b
    return false unless t3.reg_a == 0 && t3.reg_b == 0
    return false unless t2.immediate == 1 && t3.immediate == 1
    return false unless references[i + 2]?.nil? && references[i + 3]?.nil?
    t0_ref = references[i]?
    return false unless t0_ref && t0_ref[:ref].kind.lui? && t0_ref[:definition_offset]
    t1_ref = references[i + 1]?
    return false unless t1_ref && t1_ref[:ref].kind.lli? && t1_ref[:definition_offset]
    return false unless t0_ref[:definition_offset] == t1_ref[:definition_offset]
    return false unless t0_ref[:ref].offset == t1_ref[:ref].offset
    symbol_value = definitions[t0_ref[:definition_offset].not_nil!][:new_address] + t0_ref[:ref].offset
    relative_value = symbol_value - t0_ref[:new_address]
    return false if overflow_immediate_offset? relative_value
    symbol = t0_ref[:name]
    references[i].not_nil![:ref].kind = :beq
    references[i + 1] = nil
    references[i + 2] = nil
    references[i + 3] = nil
    references[i + 4] = nil
    text[i] = Instruction.new(ISA::Beq, comp_reg_a, comp_reg_b, 0).encode
    sum_text[i + 1] = 0
    sum_text[i + 2] = 0
    sum_text[i + 3] = 0
    sum_text[i + 4] = 0
    return true
  end

  def detect_local_near_move_jalr(i, t0, t1, t2, references, definitions, sum_text, text)
    return false unless t0 && t1 && t2
    return false unless sum_text[i] == 1 && sum_text[i + 1] == 1 && sum_text[i + 2] == 1
    return false unless t0.opcode.lui? && t1.opcode.addi? && t2.opcode.jalr?
    return false unless t2.reg_a == 0
    return false unless t2.immediate == 0
    address_reg = t0.reg_a
    return false unless t1.reg_a == address_reg && t1.reg_b == address_reg && t2.reg_b == address_reg
    t0_ref = references[i]?
    return false unless t0_ref && t0_ref[:ref].kind.lui? && t0_ref[:definition_offset]
    t1_ref = references[i + 1]?
    return false unless t1_ref && t1_ref[:ref].kind.lli? && t1_ref[:definition_offset]
    return false unless t0_ref[:definition_offset] == t1_ref[:definition_offset]
    return false unless t0_ref[:ref].offset == t1_ref[:ref].offset
    symbol_value = definitions[t0_ref[:definition_offset].not_nil!][:new_address] + t0_ref[:ref].offset
    relative_value = symbol_value - t0_ref[:new_address]
    return false if overflow_immediate_offset? relative_value
    symbol = t0_ref[:name]
    references[i].not_nil![:ref].kind = :beq
    references[i + 1] = nil
    references[i + 2] = nil
    text[i] = Instruction.new(ISA::Beq, 0, 0, 0).encode
    sum_text[i + 1] = 0
    sum_text[i + 2] = 0
    return true
  end

end